# 12.1. Очистити текст від html-тегів
# Ваше завдання написати функцію, яка прочитає заданий файл, очистить текст від html-тегів і запише цей текст в інший файл.
# html-тег завжди починається з "<" і закінчується на ">" тобто. потрібно видалити ці символи та все, що між ними.
# Функція отримує на вхід два параметри – ім'я файлу, який потрібно очистити, та ім'я файлу,
# куди потрібно записати очищений текст.
# Ім'я файлу, куди потрібно писати, можна задати за замовчуванням.
# Приклади файлів у вкладенні – файл який потрібно очистити (draft.html) та приклад файлу, який може вийти на виході з очищеним текстом (cleaned.txt).
# Файл draft.html необхідно скачати і покласти поряд з файлом, де буде вирішення цієї домашки.
# Додаткове завдання для тих, хто захоче ускладнити рішення - спробуйте прибрати рядки, в яких немає інформації.
#
# import codecs
# def delete_html_tags(html_file, result_file='cleaned.txt'):
#     with codecs.open(html_file, 'r', 'utf-8') as file:
#         html = file.read()
##################################
# Основные символы в регулярных выражениях:
# .       - любой одиночный символ, кроме новой строки
# *       - 0 или более повторений предыдущего символа
# +       - 1 или более повторений предыдущего символа
# ?       - 0 или 1 повторение предыдущего символа (делает квантификатор жадным)
# \s      - любой пробельный символ (пробел, табуляция, новая строка и т.д.)
# \S      - любой непробельный символ
# \d      - любая цифра (0-9)
# \D      - любой нецифровой символ
# \w      - любой алфавитно-цифровой символ (буквы, цифры и подчеркивание)
# \W      - любой неалфавитно-цифровой символ
# ^       - начало строки
# $       - конец строки
# []      - набор символов (например, [a-z] соответствует любой строчной букве)
# ()      - группа символов (например, (abc) соответствует строке "abc")
# |       - логическое ИЛИ (например, a|b соответствует "a" или "b")
# {}      - количество повторений (например, a{3} соответствует "aaa")
import codecs
import re

def delete_html_tags(html_file, result_file='cleaned.txt'):
    """
    Функция для очистки текста от html-тегов и записи очищенного текста в другой файл.

    :param html_file: Имя файла, который нужно очистить.
    :param result_file: Имя файла, куда нужно записать очищенный текст (по умолчанию 'cleaned.txt').
    """
    # Чтение содержимого файла
    with codecs.open(html_file, 'r', 'utf-8') as file:
        html = file.read()

    # Удаление <script> тегов и их содержимого
    cleaned_text = re.sub(r'<script.*?>.*?</script>', '', html, flags=re.DOTALL)  # <script>...</script>
    # <       - начало тега
    # script  - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </script> - закрывающий тег

    # Удаление <style> тегов и их содержимого
    cleaned_text = re.sub(r'<style.*?>.*?</style>', '', cleaned_text, flags=re.DOTALL)  # <style>...</style>
    # <       - начало тега
    # style   - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </style> - закрывающий тег

    # Удаление комментариев
    cleaned_text = re.sub(r'<!--.*?-->', '', cleaned_text, flags=re.DOTALL)  # <!--...-->
    # <!--    - начало комментария
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # -->     - конец комментария

    # Удаление <meta> тегов
    cleaned_text = re.sub(r'<meta.*?>', '', cleaned_text)  # <meta ...>
    # <       - начало тега
    # meta    - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега

    # Удаление <head> тегов и их содержимого
    cleaned_text = re.sub(r'<head.*?>.*?</head>', '', cleaned_text, flags=re.DOTALL)  # <head>...</head>
    # <       - начало тега
    # head    - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </head> - закрывающий тег

    # Удаление <link> тегов
    cleaned_text = re.sub(r'<link.*?>', '', cleaned_text)  # <link ...>
    # <       - начало тега
    # link    - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега

    # Удаление <img> тегов
    cleaned_text = re.sub(r'<img.*?>', '', cleaned_text)  # <img ...>
    # <       - начало тега
    # img     - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега

    # Удаление <nav> тегов и их содержимого
    cleaned_text = re.sub(r'<nav.*?>.*?</nav>', '', cleaned_text, flags=re.DOTALL)  # <nav>...</nav>
    # <       - начало тега
    # nav     - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </nav>  - закрывающий тег

    # Удаление <form> тегов и их содержимого
    cleaned_text = re.sub(r'<form.*?>.*?</form>', '', cleaned_text, flags=re.DOTALL)  # <form>...</form>
    # <       - начало тега
    # form    - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </form> - закрывающий тег

    # Удаление <audio> тегов и их содержимого
    cleaned_text = re.sub(r'<audio.*?>.*?</audio>', '', cleaned_text, flags=re.DOTALL)  # <audio>...</audio>
    # <       - начало тега
    # audio   - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </audio> - закрывающий тег

    # Удаление <video> тегов и их содержимого
    cleaned_text = re.sub(r'<video.*?>.*?</video>', '', cleaned_text, flags=re.DOTALL)  # <video>...</video>
    # <       - начало тега
    # video   - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </video> - закрывающий тег

    # Удаление <iframe> тегов и их содержимого
    cleaned_text = re.sub(r'<iframe.*?>.*?</iframe>', '', cleaned_text, flags=re.DOTALL)  # <iframe>...</iframe>
    # <       - начало тега
    # iframe  - название тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?), включая переводы строк (DOTALL)
    # </iframe> - закрывающий тег

    # Удаление всех остальных html-тегов
    cleaned_text = re.sub(r'<.*?>', '', cleaned_text)  # <...>
    # <       - начало тега
    # .*?     - любой символ (.) ноль или более раз (*), как можно меньше (?)
    # >       - конец тега

    # Удаление пустых строк
    cleaned_text = re.sub(r'^\s*$', '', cleaned_text, flags=re.MULTILINE)  # Удаление пустых строк
    # ^       - начало строки
    # \s*     - любое количество пробельных символов
    # $       - конец строки
    # flags=re.MULTILINE - многострочный режим

    # Запись очищенного текста в другой файл
    with codecs.open(result_file, 'w', 'utf-8') as file:
        file.write(cleaned_text)

    # Чтение и вывод содержимого очищенного файла
    with codecs.open(result_file, 'r', 'utf-8') as file:
        cleaned_content = file.read()
        print(cleaned_content)

# Пример использования
delete_html_tags('draft.html', 'cleaned.txt')
print('OK')
